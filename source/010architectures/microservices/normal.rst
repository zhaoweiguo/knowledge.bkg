常用
####

微服务架构特点::

    1. 服务组件化
    2. 按业务能力组织服务
    3. 去中心化
    4. 基础设施自动化

    微服务具备业务独立、进程隔离、团队自主、技术无关轻量级通信和交付独立性等“微”特性。


微服务架构设计切入点::

    一. 首要的切入点在于服务建模，尽可能明确领域的边界。
    我们可以充分利用领域驱动设计(DDD)方法，通过:
      1. 识别领域/子域中的模块和服 务、
      2. 判断这些模块和服务是否独立、
      3. 考虑提升某些模块和服务的层次并建立充血领域模型，
    从而明确各个界限上下文( Boundary Context )之间的边界。

    二. 第二个切入点就是服务之间的集成方式
    即需要保证集成方式的技术无关性，不要选择对服务具体实现有技术性限制的集成技术。

    三. 第三个切入点在于服务的部署
    独立部署单个服务而不需要修改其他服务


微服务架构的优势::

    1. 技术优势
        a. 组件化方案
            高内聚、低搞合的组件化方案
            组件所能带来的独立性与健壮性，微服务都可以具备，
              但微服务的组件化特征更多表现在对业务的提炼和对边界的思考
            使用微服务架构迫使我们使用诸如领域驱动设计的思想去进行策略设计和技术设计，
              从而为更好地划分业务功能、提取界限上下文和开展系统集成工作提供依据。
              而这些方法和依据的背后恰恰是我们在架构设计过程中经常会碰到的问题
        b. 技术自由度
            各个微服务之间使用的是轻量级的通信机制。
            所谓轻量级，就是指这些通信机制跟具体实现技术无关，不受限与某一个特定协议或交互媒介。
            每个微服务高度独立
        c. 可扩展性
            与生俱来的可扩展性
            单个服务在保持通信方式不变的前提下，对其内部功能和技术的改变不会对外部依赖它的服务产生任何影响
        d. 可伸缩性
            高扩展性往往能够带来高可伸缩性，因为可以伸缩的前提是对系统有合理的拆分
            对是瓶颈的业务功能构建成独立的微服务，使用服务集群等手段有效加强服务运行时的环境和状态
        e. 有效应对遗留系统
            遗留系统( Legacy System )
              一方面该系统的技术体系可能府在设计上的较大缺陷
              另一方面则是因为代码量巨大且不容易修改
            在代码层次与遗留系统进行直接集成是痛苦且具有挑战性的工作
              而把遗留系统看成是提供接口的一个服务，微服务架构就能与之进行通信并完成功能整合
        f. 支持持续交付
            微服务作为独立的可部署单元，非常适合使用持续交付
              因为每一个服务都可以在不依赖于其他服务的条件下完成发布和部署
            持续交付管道可以运行得更快，从而加速问题反馈，这是持续交付的主要目标之一。
            而持续交付的另一个目标是降低系统风险，微服务小而独立，一旦出现问题很容易进行回滚操作
    2. 业务与组织优势
        康威定律( Conway’s Law)
          你想要什么样的 系统，就搭建什么样的团队

        a. 消除过程浪费
            开发周期的缩短同样意味着开发成本的降低，建立高效的研发过程体系可以提高开发效率
            微服务架构的技术特征决定了开发各自微服务的团队之间只需要进行较少的协调工作，
              这为降低研发过程浪费提供了基础
              从组织管理的角度出发，自治性团队较之集中式管理模式下的团队在团队建立和发展上能够得到更好的可扩展性
            另一方面 ，软件团队中时常会出现所谓的“扯皮现象” 原因在于不清晰的边界
              微服务架构的一大特征就是根据业务来组建团队，
              某个特定业务局限于某个微服务中并由独立团队负责所有相关事宜。
              明确的边界有助于减少团队之间的扯皮现象，从而提升开发效率。
        b. 快速产品开发
            微服务架构从技术角度给出了缩短产品开发周期的方法，主要表现在并行的开发模式上
            将业务拆分成各个微服务能够让不同的业务功能处于一种并行开发的状态，
            因为每个团队所负责的业务需求只影响到团队自身的微服务，所以各个团队能够独立开发，
            整个系统也很容易分 布到各个团队中


微服务架构的挑战::

    将一个系统分散到多个微服务中使得系统整体结构变得更加复杂
    由于各个微服务都需要独立部署，我们就会有更多的服务需要单独进行发布和运行管理，运维基础设施也会面临比单块系统更大的困难 
    微服务架构在很大程度上改变了系统的研发过程 ， 从团队协作到需求管理等方面，都需要通过引人变化进 行调整和完善 。

    1. 技术架构挑战
        a. 去中心化与平衡
            去中心化的设计思想意味着微服务之间不需要共享技术，然而缺少通用的技术体系同样也会加剧系统的复杂度
            去中心化是微服务架构的基本特征之一，所以支持「技术异构」(从而增加技术复杂性)
            但从统一发布和运维等角度去看待整个系统时，这种技术复杂性就可能会是一个问题

        b. 服务版本控制
            如果某一个服务与另一个服务具有版本关联性，
              即这两个服务要么都不发布、要么一起发布，那么事情就变得有点复杂。
            如果这些具有版本关联性的服务很多且版本的更新频率很高，
              如何正确地管理服务版本就是一项具有挑战性的工作。

    2. 研发过程挑战
        a. 需求的边界
            对于整个系统而言，需求的边界并不会那么容易划分
            如何确定业务功能的粒度、
            如何把非功能性需求分解到各个微服务中、
            如何从系统整体上把握需求的优先级
        b. 引入变化
            使用微服务架构就是一个引入变化的过程。
            最大的误解: 认为新想法一旦引入就意味着已经成功
            当微服务架构被引入时，我们还要做很多事情，
              因为前面所提到的各种技术、架构和过程的挑战都需要我们进行跟踪和协调

微服务架构实施前提::

    1. 当出现下图这个拐点时对系统进行微服务化的拆分才是合适的方案，服务的合理拆分是实施微服务架构的一大前提。
    2. 微服务架构实施的另外一个前提是基础设施的自动化
        一个应用部署到一台主机或在主机集群上，部署复杂度是 o(n)
        而当把单块系统拆分成多个微服务之后，其部署复杂度就上升到 o(n^2)
        从开发之后的构建、测试、部署都需要高度自动化的环境来支撑才能有效降低边际成本


.. figure:: /images/architectures/microservices/complexity.png

    生产率和复杂度关系图——马丁·福勒(Martin Fowler)。在复杂度较小时，采用单块系统的生产率更高，微服务架构反而可能降低生产率。当复杂度到了一定规模时，无论采用单块系统还是微服务架构，都会降低系统的生产率。但是单块系统的生产率开始急剧下降，而微服务架构则能缓解这种生产率下降的程度。本图展示了复杂度和生产率拐点的存在，但并没有量化复杂度的拐点到底是多少。也就是说，系统或代码库的规模达到 具体多大才适合开捕挂行微服务化的拆分，需要各个团队因地制宜。

微服务建模
==========

服务分类
--------

定义::

    从技术实现角度和业务角度分别切入，梳理微服务架构中的代表性服务类型和表现层次
    一方面可以从技术实现角度进行归类;
    另一方面，服务也具备层次性，需要把服务与业务结合起来梳理服务层次。


服务的基本类别
''''''''''''''

技术平台在构成过程中可以采用大量成熟的技术理念和工具，基本思路就是实现服务化。

三种主要的表现类型::

    1. 工具服务
    2. 实体服务
    3. 任务服务

1. 工具服务( Utility Service )
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

定义::

    代表: 可重用服务，区别业务模型。
    作为: 应用程序与技术基础设施之间的交叉点
    特点: 业务领域无关
    本质: 面向技术、具备高可重用性的低层处理服务，因此能够遵循独立开发和管理生命周期

工具服务的四个常见维度::

    1. Java 标准的 API 的封装
        JCE(Java Cryptography Extension, Java 密码扩展)
            提供用于加密、密钥生成和协商以及消息认证码 ( Message Authentication Code , MAC )算法的框架和实现
        JMS(Java Messaing Service, Java 消息服务)
            提供面向消息中间件( Message Oriented Middleware, MOM )的 API 规范
        JAX-RS (Java API for RESTful Web Services)
            支持按照 REST 风格创建 Web 服务
        JDBC, 
    2. 公共功能区域的提炼
        安全性、
        消息传递系统、
        HTTP 数据传输
        持久性
    3. 非功能性需求的抽取
        性能、
        可扩展性、
        可用性、
        安全性
    4. 常见开源框架的应用
        Zookeeper: 实现分布式协调和分布式锁机制
        Dubbo: 实现通用的 RPC 功能和服务治理
        Redis: 实现海量数据存储
        Mongodb
    注: 以 Java 为例

工具服务根据其用途细分为以下表现形式::

    1. 公共工具服务
        面向多种应用程序，如安全性、记录和审核，
        该类工具服务通常设计成基于 Web的服务，并开放通用、松散类型接口。
    2. 资源工具服务
        封装物理系统资源，如数据存储/消息资源
        这类服务处于底层，使用服务门面暴露入口
    3. 微工具服务
        细粒度、高度特性化，如XML加密服务。
        这类服务通常本地调用，需要考虑性能、无状态性和线程安全，可以作为 JAR 包进行直接引用
    4. 包装器工具服务
        面向遗留系统，建立标准化服务契约
        显然这类服务需要明确所支持的数据和消息模型


实体服务( Entity Service )
~~~~~~~~~~~~~~~~~~~~~~~~~~

建立一种一致的方法访问和处理业务数据，对应基于业务的 功能上下文，侧重于以数据为中心。

实体服务中包括两种实体::

    领域实体( Domain Entity)
    消息实体( Message Entity)

任务服务( Task Service )
~~~~~~~~~~~~~~~~~~~~~~~~

关注实现业务相关逻辑，很大程度上由组合逻辑组成，通常需 要维护状态


.. note::  工具服务不涉及业务。实体服务关注于数据，任务服务关注于业务组合，都需要根据业 务本身抽象化 。




服务与业务
''''''''''

业务服务的层次分类::

    1. 基础服务
        基础服务处于业务体系的最低层，这些服务一般对用户并不可见，
        但却被其他各种服务所依赖，或者说为其他服务提供运行时支撑
        如: 消息服务、路由服务
        这些服务是业务体系中与技术结合比较密切的一组服务，
        有时候也很难区分基础服务中业务和技术之间的隔离点
    2. 通用服务
        通用服务与基础服务的区别就在于它们是完全面向业务的服务，
        这些服务通用性非常高，也可以像基础服务一样提供低层的业务支撑
        如: 账号服务、登录服务、通知服务
        「基础服务」与「通用服务」的区分可参考以下判断标准: 
            如果一个服务被依赖的层次和数量非常多，
            那么可能会更加偏向于基础服务，反之则可以归为通用服务。
    3. 定制服务
        在一个系统中，定制服务相对而言不应该太多，
        在日常开发过程中，定制服务主要是「面向外部」、「面向系统集成类」
        如: 各种插件( Plug-in )类服务、外部账号和接口管理类服务
        一方面需要对第三方服务进行适配，通常都需要进行一定程度的定制化开发
        另一方面，为了系统的灵活性和扩展性，需单独把这部分从核心业务中剥离出来单独管理
    4. 其他服务
        这些服务因行业和业务体系而异


.. figure:: /images/architectures/microservices/classify_example1.png

   示例——移动医疗行业场景


服务模型
--------

.. note:: 架构师使用模型来表达系统架构

服务的概念模型
''''''''''''''


定义::

    提供服务的概念模型，并给出服务的统一表现形式

    服务的概念模型来自于两个维度:
    一个是服务标准，即什么样的服务才是一个好的服务
    另一个是服务级别，即不同的服务应该具备不同的重要性

服务的概念模型::

    两个维度:
    一个是服务标准: 什么样的服务才是一个好的服务
    一个是服务级别: 不同的服务应该具备不同的重要性

服务标准: 以下设计原理是服务标准最好的描述::

    1. 服务无状态(Service Statelessness)
        定义: 指服务通过推迟或避免状态信息的管理，从而最小化资源消耗
        具备无状态的服务的设计特征:
            a. 高度业务流程无关的逻辑，使得服务没有被设计为保存任何特定业务流程中的状态信息
            b. 服务契约的约束很少，从而能够在运行时接收和传输更广泛的状态数据等
        服务无状态性有助于增强服务的可扩展性。
    2. 服务可重用( Service Reusability )
        首先需要确保建立无关功能性的上下文 (Context )结构，
            也就是说与服务封装在一起的上下文对任何使用场景都有足够的无关性，
            这样服务才能被认为具备可重用性。
        同时，服务内部的业务逻辑足够通用，以便能够用到不同类型的服务消费者的众多场景中
        而且，服务逻辑可以被并发访问，服务设计为在一个或多个消费者同时访问时具备同样的访问效果
    3. 服务可发现( Service Discoverability )
        定义: 指服务具备能够用于传递的元数据构建能力，通过这些元数据可以有效地发现和解释服务
        如: 在服务注册中心，可以通过这些元数据与注册中心之间建立服务注册和发现机制
    4. 服务自治( Service Autonomy )
        定义: 指服务对其低层运行时环境具有高度的控制权
        为了实现服务自治:
            服务契约应该表达定义明确的功能边界，这个边界不应该与其他服务的功能边界相重叠
            同时，服务应该被部署在一个独立而隔离的环境中，
            承载服务的这个环境也应该具备能够处理高并发的访问能力，以便更好地实现服务可伸缩性目的
    5. 服务松耦合( Service Loose Coupling )
        主要目的在于为消费者提供较低的耦合度要求，
        通常表现在服务提供者和服务消费者能够以适应性的方式随时间进行自我演化，彼此之间的影响达到最小
        在实现服务的过程中，服务松耦合原则强调服务契约与技术实现细节上的解捐

服务级别::

    从发生具体事故时服务对用户体验的影响、所造成的经济损失等角度对服务进行具体分级
    1. 一级服务
        具备完善的容错降级机制及对低级别服务的熔断措施、定期压测、配置高级别的监控告警流程
    2. 二级服务
        多采用异步方式进行系统交互，容忍暂时数据不一致性
    3. 三级服务
        可随时降级整个服务


服务的统一表现形式
''''''''''''''''''

也就是需要具备契约化的约束条件，而这种契约化的约束条件一般可以通过文档的方式进行展现 

服务契约化(Service Contract)::

    要求至少对服务的基本方面做出说明，包括:
        1. API: 详细文档
        2. 能力: 服务能力的描述
        3. 约束: 约定的一些限制条件说明
        4. 版本: 支持的最新和历史的版本说明。这一点对于微服务而言是必备的要素


文挡服务::

    Swagger
    HAL



服务边界
--------

::

    服务边界是服务建模的核心要素，
    采用面向领域思想，通过识别业务领域边界并确定界限上下文来达到明确服务边界的效果

    识别服务的切入点在于 识别服务与服务之间的边界( Boundary )






服务数据
--------

::

    对于微服务而言，传统的规范化数据模型存在一定的问题
    需要通过数据去中心化手段实现对服务数据的有效管理




参考
====

* 【书】《微服务设计原理与架构》













